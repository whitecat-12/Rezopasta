<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Interactive Markerless AR</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; touch-action: none; }
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js';
import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/webxr/ARButton.js';
import { XRHitTestSource } from 'https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/webxr/XRHitTestSource.js';

// Scene & Camera
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera();
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

// AR Button
document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

// Lighting
const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
scene.add(light);

// Raycaster & touch variables
const raycaster = new THREE.Raycaster();
const touch = new THREE.Vector2();
let selectedCube = null;

// List of cubes
const cubes = [];

// Hit test variables
let hitTestSource = null;
let localSpace = null;

// Start AR session
renderer.xr.addEventListener('sessionstart', async () => {
  const session = renderer.xr.getSession();
  const refSpace = await session.requestReferenceSpace('viewer');
  hitTestSource = await session.requestHitTestSource({ space: refSpace });
  localSpace = await session.requestReferenceSpace('local');
});

// Tap to place cube
renderer.domElement.addEventListener('touchstart', async (event) => {
  event.preventDefault();
  const session = renderer.xr.getSession();
  const touchEvent = event.touches[0];
  touch.x = (touchEvent.clientX / window.innerWidth) * 2 - 1;
  touch.y = -(touchEvent.clientY / window.innerHeight) * 2 + 1;

  // If tapping existing cube, select it
  raycaster.setFromCamera(touch, camera);
  const intersects = raycaster.intersectObjects(cubes);
  if (intersects.length > 0) {
    selectedCube = intersects[0].object;
    return;
  }

  // Else, place new cube using hit-test
  const frame = renderer.xr.getFrame();
  if (hitTestSource && frame) {
    const hitTestResults = frame.getHitTestResults(hitTestSource);
    if (hitTestResults.length > 0) {
      const hit = hitTestResults[0];
      const pose = hit.getPose(localSpace);
      const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
      const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
      scene.add(cube);
      cubes.push(cube);
      selectedCube = cube;
    }
  }
});

// Drag cube
renderer.domElement.addEventListener('touchmove', (event) => {
  event.preventDefault();
  if (!selectedCube) return;

  const touchEvent = event.touches[0];
  touch.x = (touchEvent.clientX / window.innerWidth) * 2 - 1;
  touch.y = -(touchEvent.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(touch, camera);
  const intersects = raycaster.intersectObjects(cubes);
  if (intersects.length > 0) {
    selectedCube.position.copy(intersects[0].point);
  }
});

// Release cube
renderer.domElement.addEventListener('touchend', () => {
  selectedCube = null;
});

// Animation loop
renderer.setAnimationLoop(() => {
  renderer.render(scene, camera);
});
</script>
</body>
</html>
